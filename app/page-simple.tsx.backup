"use client";
import { useState, useEffect, useRef, useCallback } from "react";
import { useMiniKit } from "@coinbase/onchainkit/minikit";
import { useAccount } from "wagmi";
import styles from "./game.module.css";

type GameState = "ready" | "playing" | "gameover" | "leaderboard";

interface Obstacle {
  id: number;
  x: number;
  height: number;
}

interface LeaderboardEntry {
  player: string;
  score: number;
  timestamp: number;
}

export default function Home() {
  const { isFrameReady, setFrameReady, context } = useMiniKit();
  const { address, isConnected } = useAccount();
  
  // Game state
  const [gameState, setGameState] = useState<GameState>("ready");
  const [score, setScore] = useState(0);
  const [bestScore, setBestScore] = useState(0);
  const [playerY, setPlayerY] = useState(300);
  const [velocity, setVelocity] = useState(0);
  const [obstacles, setObstacles] = useState<Obstacle[]>([]);
  const [energy, setEnergy] = useState(3);
  const [leaderboard, setLeaderboard] = useState<LeaderboardEntry[]>([]);
  const [isJumping, setIsJumping] = useState(false);
  
  // Game refs
  const gameLoopRef = useRef<number>();
  const obstacleIdRef = useRef(0);
  const gameSpeedRef = useRef(5);

  // Initialize the miniapp
  useEffect(() => {
    if (!isFrameReady) {
      setFrameReady();
    }
  }, [setFrameReady, isFrameReady]);

  // Load player stats (mock for now - will integrate with contract later)
  useEffect(() => {
    if (isConnected && address) {
      // TODO: Load from smart contract
      const saved = localStorage.getItem(`baserunner_${address}`);
      if (saved) {
        const data = JSON.parse(saved);
        setBestScore(data.bestScore || 0);
        setEnergy(data.energy || 3);
      }
    }
  }, [isConnected, address]);

  // Game physics constants
  const GRAVITY = 0.6;
  const JUMP_FORCE = -12;
  const GROUND_Y = 300;
  const PLAYER_SIZE = 40;
  const OBSTACLE_WIDTH = 40;
  const OBSTACLE_GAP = 300;

  // Jump function
  const jump = useCallback(() => {
    if (gameState === "playing" && playerY >= GROUND_Y - 5) {
      setVelocity(JUMP_FORCE);
      setIsJumping(true);
      setTimeout(() => setIsJumping(false), 300);
    }
  }, [gameState, playerY, JUMP_FORCE, GROUND_Y]);

  // Start game
  const startGame = useCallback(() => {
    if (energy <= 0) {
      alert("No energy left! Wait for refill or use tokens to continue.");
      return;
    }
    
    setGameState("playing");
    setScore(0);
    setPlayerY(GROUND_Y);
    setVelocity(0);
    setObstacles([]);
    obstacleIdRef.current = 0;
    gameSpeedRef.current = 5;
    setEnergy(prev => Math.max(0, prev - 1));
  }, [energy, GROUND_Y]);

  // Game over
  const gameOver = useCallback(() => {
    setGameState("gameover");
    if (gameLoopRef.current) {
      cancelAnimationFrame(gameLoopRef.current);
    }
    
    // Update best score
    if (score > bestScore) {
      setBestScore(score);
      if (isConnected && address) {
        localStorage.setItem(`baserunner_${address}`, JSON.stringify({
          bestScore: score,
          energy
        }));
        // TODO: Submit to smart contract
      }
    }
  }, [score, bestScore, isConnected, address, energy]);

  // Check collision
  const checkCollision = (pY: number, obs: Obstacle[]) => {
    const playerBottom = pY + PLAYER_SIZE;
    const playerRight = 100 + PLAYER_SIZE;
    
    for (const obstacle of obs) {
      const obstacleLeft = obstacle.x;
      const obstacleRight = obstacle.x + OBSTACLE_WIDTH;
      const obstacleTop = GROUND_Y + PLAYER_SIZE - obstacle.height;
      
      if (
        100 < obstacleRight &&
        playerRight > obstacleLeft &&
        playerBottom > obstacleTop
      ) {
        return true;
      }
    }
    return false;
  };

  // Main game loop
  useEffect(() => {
    if (gameState !== "playing") return;

    const gameLoop = () => {
      setPlayerY(prev => {
        let newY = prev + velocity;
        if (newY >= GROUND_Y) {
          newY = GROUND_Y;
          setVelocity(0);
        } else {
          setVelocity(v => v + GRAVITY);
        }
        return newY;
      });

      setObstacles(prev => {
        const newObstacles = prev
          .map(obs => ({ ...obs, x: obs.x - gameSpeedRef.current }))
          .filter(obs => obs.x > -OBSTACLE_WIDTH);

        // Add new obstacles
        if (newObstacles.length === 0 || newObstacles[newObstacles.length - 1].x < 800 - OBSTACLE_GAP) {
          const height = 40 + Math.random() * 60;
          newObstacles.push({
            id: obstacleIdRef.current++,
            x: 800,
            height
          });
        }

        // Check for passed obstacles (score)
        newObstacles.forEach(obs => {
          if (obs.x + OBSTACLE_WIDTH < 100 && obs.x + OBSTACLE_WIDTH > 100 - gameSpeedRef.current) {
            setScore(s => {
              const newScore = s + 1;
              // Increase speed every 5 points
              if (newScore % 5 === 0) {
                gameSpeedRef.current = Math.min(12, gameSpeedRef.current + 0.5);
              }
              return newScore;
            });
          }
        });

        // Check collision
        if (checkCollision(playerY, newObstacles)) {
          gameOver();
        }

        return newObstacles;
      });

      gameLoopRef.current = requestAnimationFrame(gameLoop);
    };

    gameLoopRef.current = requestAnimationFrame(gameLoop);

    return () => {
      if (gameLoopRef.current) {
        cancelAnimationFrame(gameLoopRef.current);
      }
    };
  }, [gameState, playerY, velocity, gameOver]);

  // Keyboard controls
  useEffect(() => {
    const handleKeyPress = (e: KeyboardEvent) => {
      if (e.code === "Space" || e.code === "ArrowUp") {
        e.preventDefault();
        if (gameState === "ready") {
          startGame();
        } else if (gameState === "playing") {
          jump();
        } else if (gameState === "gameover") {
          startGame();
        }
      }
    };

    window.addEventListener("keydown", handleKeyPress);
    return () => window.removeEventListener("keydown", handleKeyPress);
  }, [gameState, jump, startGame]);

  // Touch/click controls
  const handleTap = () => {
    if (gameState === "ready") {
      startGame();
    } else if (gameState === "playing") {
      jump();
    } else if (gameState === "gameover") {
      startGame();
    }
  };

  const showLeaderboard = () => {
    setGameState("leaderboard");
    // TODO: Fetch from smart contract
    setLeaderboard([
      { player: "0x1234...5678", score: 127, timestamp: Date.now() },
      { player: "0xabcd...efgh", score: 98, timestamp: Date.now() },
      { player: "0x9876...5432", score: 85, timestamp: Date.now() },
    ]);
  };

  return (
    <div className={styles.gameContainer} onClick={handleTap}>
      {/* Header */}
      <div className={styles.header}>
        <div className={styles.stats}>
          <span className={styles.energy}>‚ö° {energy}/3</span>
          <span className={styles.scoreDisplay}>Score: {score}</span>
          <span className={styles.bestScore}>Best: {bestScore}</span>
        </div>
        {context?.user?.displayName && (
          <div className={styles.userName}>üëã {context.user.displayName}</div>
        )}
      </div>

      {/* Game Canvas */}
      <div className={styles.gameCanvas}>
        {/* Ground */}
        <div className={styles.ground}></div>
        
        {/* Player */}
        <div
          className={`${styles.player} ${isJumping ? styles.jumping : ""}`}
          style={{ bottom: `${playerY}px` }}
        >
          üèÉ
        </div>

        {/* Obstacles */}
        {obstacles.map(obstacle => (
          <div
            key={obstacle.id}
            className={styles.obstacle}
            style={{
              left: `${obstacle.x}px`,
              height: `${obstacle.height}px`,
              bottom: `${GROUND_Y + PLAYER_SIZE}px`
            }}
          />
        ))}

        {/* UI Overlays */}
        {gameState === "ready" && (
          <div className={styles.overlay}>
            <h1 className={styles.gameTitle}>üèÉ BASE RUNNER</h1>
            <p className={styles.instructions}>Tap or press SPACE to jump!</p>
            <button className={styles.startButton} onClick={startGame}>
              START GAME
            </button>
            <button className={styles.leaderboardButton} onClick={showLeaderboard}>
              üèÜ LEADERBOARD
            </button>
          </div>
        )}

        {gameState === "gameover" && (
          <div className={styles.overlay}>
            <h2 className={styles.gameOverTitle}>GAME OVER!</h2>
            <div className={styles.finalScore}>
              <p>Score: <strong>{score}</strong></p>
              {score > bestScore && <p className={styles.newRecord}>üéâ NEW RECORD!</p>}
              <p>Best: {bestScore}</p>
            </div>
            <div className={styles.gameOverButtons}>
              <button className={styles.retryButton} onClick={startGame}>
                RETRY ({energy} ‚ö° left)
              </button>
              <button className={styles.shareButton} onClick={() => {
                // TODO: Implement Farcaster share
                alert(`I scored ${score} in Base Runner! Can you beat me? üèÉ‚Äç‚ôÇÔ∏è`);
              }}>
                üì¢ SHARE
              </button>
              <button className={styles.leaderboardButton} onClick={showLeaderboard}>
                üèÜ LEADERBOARD
              </button>
            </div>
          </div>
        )}

        {gameState === "leaderboard" && (
          <div className={styles.overlay}>
            <h2 className={styles.leaderboardTitle}>üèÜ TOP PLAYERS</h2>
            <div className={styles.leaderboardList}>
              {leaderboard.map((entry, index) => (
                <div key={index} className={styles.leaderboardEntry}>
                  <span className={styles.rank}>#{index + 1}</span>
                  <span className={styles.playerAddress}>{entry.player}</span>
                  <span className={styles.playerScore}>{entry.score}</span>
                </div>
              ))}
            </div>
            <button className={styles.backButton} onClick={() => setGameState("ready")}>
              BACK
            </button>
          </div>
        )}
      </div>

      {/* Footer */}
      <div className={styles.footer}>
        <p>üîó Powered by Base</p>
        {!isConnected && <p className={styles.connectWallet}>Connect wallet to save scores onchain</p>}
      </div>
    </div>
  );
}
